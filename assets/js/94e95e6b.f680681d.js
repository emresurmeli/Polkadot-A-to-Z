"use strict";(self.webpackChunkpolkadot_a_to_z=self.webpackChunkpolkadot_a_to_z||[]).push([[324],{5969:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"J-for-Polkadot-JS","metadata":{"permalink":"/Polkadot-A-to-Z/blog/J-for-Polkadot-JS","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/J for Polkadot JS/index.md","source":"@site/blog/J for Polkadot JS/index.md","title":"J for Polkadot JS","description":"J for Polkadot JS","date":"2021-12-04T01:28:05.074Z","formattedDate":"December 4, 2021","tags":[],"readingTime":3.795,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"nextItem":{"title":"I for Interoperability","permalink":"/Polkadot-A-to-Z/blog/I-for-Interoperability"}},"content":"![J for Polkadot JS](./J.png)\\n\\nPolkadot.js is a collection of tools that interfaces with the Polkadot blockchain in very granular ways. Polkadot.js as a term has multiple moving parts that are worth mentioning:\\n\\n\\n1. **[Polkadot.js UI](https://polkadot.js.org/)**\\n    1. This is the hosted application that loads when you navigate to in your browser and click apps wallet(hosted). This is also sometimes called \u201cPolkadot-JS App\u201d.\\n2. **[Polkadot.js API](https://github.com/polkadot-js/api)**\\n    2. This is the JavaScript API, a reusable library to allow programs to interface with the functionality of Polkadot. \\n3. **[Polkadot.js Extension](https://polkadot.js.org/extension/)**\\n    3. This is the Chrome extension that allows you to manage your accounts and sign transactions. Note that all that it does is sign messages; it has limited functionality compared to full-featured wallets, and cannot connect to the Polkadot network itself.\\n4. **[Polkadot.js codebase](https://github.com/polkadot-js/)**\\n    4. The codebase contains all the repositories of code that are required to have the suite of tools working. You can navigate to the codebase here.\\n5. **[Polkadot.js Phishing List](https://polkadot.js.org/phishing/)**\\n    5. The Phishing List website is a community driven curation of a list of less-than-honest operators. This list of URLs and addresses are constantly updated and the polkdot.js extension uses it as a source to warn you when you navigate to a URL included in the list and blocks the addresses from the apps UI. Users can also contribute suspicious sites and addresses if they come across them.\\n\\n## Polkadot JS UI\\n\\nIn this post I will focus on the UI, a powerful web application that has granular functionality support when it comes to interacting with the Polkadot blockchain. It is not considered to be just a wallet, it has more abilities than just creating accounts or sending and receiving transactions. \\n\\n## Abilities\\n\\nAmong other things, it also allows us to:\\n\\n1. Participate in staking\\n2. Take part in governance\\n3. Contribute to parachain crowdloans \\n4. Run Parachain auctions\\n5. Query chain metadata\\n6. Query on-chain data using RPC calls\\n\\nEssentially, it allows you to perform all functionality that a  user can do on either the relay chain, or any parachain (although the user interface may not be aligned exactly with the functionality of any individual parachain). Thanks to [Jaco](https://www.parity.io/blog/people-of-parity-jaco-greeff/) from Parity, it has been keeping up with the developments of the Polkadot runtime which is implemented in Rust. As a developer if you\u2019re building a Substrate based blockchain, you can utilise the Polkadot.js UI to test your code\'s functionality.\\n\\nAll in all, interacting with the Polkadot JS UI comes down to either querying on-chain data, or issuing an extrinsic. Let\'s talk about what that means exactly.\\n\\n## Querying on-chain data\\n\\nIn order to populate the UI, the web application queries the Polkadot.js API. The API then queries a Polkadot node, and uses JavaScript to return information that the UI will display on the screen. You can choose which node to connect to by changing it in the upper-left hand corner of the screen.\\n\\n## Issuing an extrinsic\\n\\nExtrinsics are pieces of information that come from outside the chain and are included in a block. Extrinsics can be one of three types: **inherents**, **signed** and **unsigned transactions**. Most extrinsics made from the Polkadot JS UI will be signed transactions. **Inherits** are non-signed and non-gossiped pieces of information included in blocks by the block author, such as timestamps, which are \u201ctrue\u201d because a sufficient number of validators have agreed about validity. **Unsigned transactions** are information that do not require a signature but will require some sort of spam prevention. **Signed transactions** are issued by the originator account of a transaction which contains a signature of that account, which will be subject to a fee to have it included on the chain. \\n\\n## Considerations\\n\\nThere have been concerns raised  by the community about the complexity of Polkadot-JS UI . However the aim of Polkadot.js UI is to support as much functionality that the relay chain requires of its users. Everytime there is a runtime update(which can be quite often) there is a potential change that needs to be made on the Polkadot.js codebase. For example, with most 3rd party wallets, when there are runtime updates they will usually need to add support for it. Polkadot.js UI is not focused as much on a user-friendly UI, but rather to support the Polkadot runtime without any bugs. \\n\\nFor more user-friendly but simpler wallet implementations, check out the wiki page where we list [Parity-developed and Treasury funded wallet projects](https://wiki.polkadot.network/docs/build-wallets#treasury-funded-wallets)\\n\\nTake a look at some of the educational content we have created to learn more about Polkadot.js\\n\\n[Introduction to Polkadot.js](https://www.youtube.com/watch?v=4EQqwGFV1D8)\\n\\n[Create an account using Polkadot.js](https://www.youtube.com/watch?v=sy7lvAqyzkY)"},{"id":"I-for-Interoperability","metadata":{"permalink":"/Polkadot-A-to-Z/blog/I-for-Interoperability","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/I for Interoperability/index.md","source":"@site/blog/I for Interoperability/index.md","title":"I for Interoperability","description":"I for Interoperability","date":"2021-12-03T00:21:19.027Z","formattedDate":"December 3, 2021","tags":[],"readingTime":3.37,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"J for Polkadot JS","permalink":"/Polkadot-A-to-Z/blog/J-for-Polkadot-JS"},"nextItem":{"title":"H for Hash","permalink":"/Polkadot-A-to-Z/blog/h-for-hash"}},"content":"![I for Interoperability](./I.png)\\n\\nInteroperability is at the core of the Polkadot philosophy. We aspire to combat chain maximalism, and believe that the ecosystem is healthier when blockchains can communicate with each other. That\u2019s why we call ourselves a Layer 0 multi-chain platform, and with that comes the technical challenge of connecting isolated blockchain networks. In this post I will explain what Interoperability means, the difference between Layer 0 and Layer 1 chains, how we use cross-consensus messaging(XCM) to do cross-chain communication of arbitrary data, and what the different ways to connect to Polkadot are.\\n\\n## A little history: Interoperability of isolated internet networks\\n\\nStarting in the early 70s up to the 80s, the internet started as isolated networks across universities, government agencies and the military. Research fueled by these participants as well as an excited community of developers from around the globe led to the development of Transmission Control Protocol and Internet Protocol(TCP/IP) which allowed these isolated networks to connect, locate and interoperate with each other.\\nWe can think of the current state of the blockchain ecosystem as the early days of the internet; a collection of isolated blockchains that still have yet to connect under a protocol that allows them to communicate with each other. Polkadot seeks to become that protocol which will allow blockchains to interoperate. That\u2019s why we call it a Layer 0 blockchain/protocol.\\n\\n\\n## Layer 0 and Layer 1\\n\\nFrom a societal development perspective, we scaled as communities into nation states in part due to the specialization of skills. Members of society can choose to develop their skills and specialize in areas like medicine, economics, politics, manufacturing among others things; they are also able to tap into an economy of trade where those specialized skills have a marketplace. We can think of those specializations as the Layer 1 solutions: in the blockchain space these are the Bitcoins and Ethereums. And, we can also think of the economy and marketplace as the Layer 0. This is what Polkadot is aiming to be in the blockchain ecosystem. \\n\\n## XCM\\n\\nCross-Consensus Messaging(XCM) is a messaging format/paradigm that allows interoperability of Layer 1 blockchains. It is implemented at the Layer 0 level and has multiple message passing functionalities. For Layer 1 to Layer 1 there is Cross-chain Message Passing(XCMP) which is yet to be implemented but is near ready based on Gavins recent blog post. Layer 1 to Layer 0 aka from parachains to the relay chain, there is Upwards Message Passing (UMP) and Layer 0 to Layer 1 aka from the relay chain to parachains, we have Downwards Message Passing(DMP). XCM is un-opinionated about the structure of the chains on the sending and receiving end, and can pass information unstructured to many types of chains. Hence, allowing any type of chain to utilize it for interoperability. We will cover this in more detail when we get to letter X.\\n\\n## Interoperable chains: parathreads/parachains/bridges\\n\\nNow that we understand the concept of Layer 0 and Layer 1, we can talk about the types of connections Layer 1 chains can have on Polkadot. \\n\\n**Parachain**: Parachains are Layer 1 solutions that will benefit from shared consensus and the pooled security of Polkadot. Parachain slots are slowly released by the network  where potential parachain projects can place bids as parachain candidates.. Most projects choose to do a crowdloan as a fundraising mechanism to increase their bid, hence their probability of winning a slot. Once a slot is won, the parachain project gets onboarded to Polkadot and is now a part of the ecosystem.\\n\\n**Parathread**: All Parachains are by default Parathreads. Parathreads are under-the-hood parachain slots but allow multiple chains to reside in them, allowing chains to participate in consensus on a per block basis. For some projects it might not make sense economically to reside in a parachain slot full time, for those projects we have parathreads. \\n\\n**Bridge**: Bridges are for already established, economically sovereign chains that have an already established network. There are still ways for those networks to connect to Polkadot and benefit from the economy."},{"id":"h-for-hash","metadata":{"permalink":"/Polkadot-A-to-Z/blog/h-for-hash","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/H for Hash/index.md","source":"@site/blog/H for Hash/index.md","title":"H for Hash","description":"H for Hash","date":"2021-12-03T00:21:19.025Z","formattedDate":"December 3, 2021","tags":[],"readingTime":2.955,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"I for Interoperability","permalink":"/Polkadot-A-to-Z/blog/I-for-Interoperability"},"nextItem":{"title":"G for Grandpa","permalink":"/Polkadot-A-to-Z/blog/g-for-grandpa"}},"content":"![H for Hash](./H.png)\\n\\nHashing, in its simplest explanation is a way to transform data. Depending on the underlying hashing algorithm, the transformation of that data happens differently. For example, Bitcoin uses the SHA-256 hashing algorithm (Simple Hashing Algorithm 2, 256bits) which returns a 256-bit output, which is usually represented as an alphanumeric string. Even the slightest change of the input will modify the output of the hashing algorithm significantly. In cryptography, this is known as **diffusion**. For example, here we will just add a whitespace to the end of the input.\\n\\n    \u201cWow, such hash\u201d = 9DD40341177F8ADD02DA4DE95A572D8BCBF8E07D51726FB51162442B13BB53D6\\n\\n    \u201cWow, such hash \u201d = 8973F8EEA2536243DE4E67AEE2181E3D4C6470B1BA64E0C632E5C91EEDC47108\\n\\n\\t\\nNo matter the length of the input data, the hashing function will always return the same sized output. It is a deterministic function, so it always produces the same output for the same input.. This output is useful in many ways, such as the ability to quickly verify and validate data sets of any size. \\n\\nHashes are a fundamental component of blockchain technology and we use them in a lot of its parts. For example, we can hash transactions and then query them by their hash. We can hash a collection of transactions and create a transaction root hash, we can hash block data which include transactions and metadata about the transactions then use that output hash as the block\'s unique ID. In newer generations of blockchains, we hash function calls and their outputs, we even hash new runtime updates.\\n\\nTo understand blockchain, it is important to understand cryptographic hash functions. Well-designed cryptographic hash functions will have the following properties:\\n\\n### Properties of a Cryptographic Hash Function\\n\\n**Deterministic**: The same input should always have the same output.\\n\\n**Quick computation**: We need to ensure that the computation of the function is fast.\\n\\n**Preimage resistance(confusion)**: We need to be sure that the hashing output cannot be reverse engineered to find out what the original input was.\\n\\n**A small change in the input changes the output(diffusion)**: Even the slightest change in the input should alter the output significantly.\\n\\n**Collision-resistant**: We need to be sure that each unique input maps to a unique output. \\n\\n**Second preimage resistance**: Given a hash function and its output, we should not be able to generate an input (or inputs) that, when hashed, produce the same output.\\n\\n\\n### Hashing vs Encryption\\n\\nHashing and encryption are related but different. **Hashing** is a one way function, meaning that we should not be able to reverse engineer the original input from just the output. **Encryption** on the other hand is a two way function. Data(plaintext) can be hidden(encrypted) by transforming it to ciphertext with the encryption key. The ciphertext can then be transformed back into the original plaintext by decrypting the ciphertext with the decryption key. The encryption and decryption key may be the same value, or different, depending on the type of cryptosystem used. \\n\\n### Hashing on Polkadot\\n\\nPolkadot and Kusama use an implementation called **BLAKE2b** which is based on the BLAKE2 cryptographic hashing algorithm. BLAKE2 is also faster than both SHA-2 and SHA-3 with similar or better security to the SHA-3.  We chose BLAKE2 for it\u2019s security, speed and simplicity of implementation. The BLAKE2b implementation is optimized for 64-bit platforms, and can be twice as performant compared to running SHA-256 algorithm on a similar machine. Due to these advantages, the project ZCash transitioned to using BLAKE2 hashing from SHA-256, projecting that BLAKE2 is improving over time while SHA-256 is getting worse. \\n\\nBlake2b hashing would look like the following:\\n\\n    \u201cWow, such hash\u201d = \\n    e530f3d3ddfc24213167e7c601733a1b688e6cf362277b46f1135e348aa63477\\n\\n    \u201cWow, such hash \u201d = \\n    f299f5ee1731f755d0f58bdc54ef3b0cadb94f7f959c3b18627e12138ed5c70e"},{"id":"g-for-grandpa","metadata":{"permalink":"/Polkadot-A-to-Z/blog/g-for-grandpa","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/G for GRANDPA/index.md","source":"@site/blog/G for GRANDPA/index.md","title":"G for Grandpa","description":"G for GRANDPA","date":"2021-12-03T00:21:19.019Z","formattedDate":"December 3, 2021","tags":[],"readingTime":2.75,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"H for Hash","permalink":"/Polkadot-A-to-Z/blog/h-for-hash"},"nextItem":{"title":"F for Forkless","permalink":"/Polkadot-A-to-Z/blog/f-for-forkless"}},"content":"![G for GRANDPA](./G.png)\\n\\n**GRANDPA**(GHOST-based Recursive ANcestor Deriving Prefix Agreement) is the finality module of the Polkadot and Kusama blockchains.\\n\\n## Finality\\n\\nIn the world of blockchains, finality is when a new block has been added to the blockchain with a certain amount of confidence that it won\u2019t be reverted and the network agrees on this new copy of the chain. It happens to be an important part of the consensus mechanism. A consensus mechanism, such as Bitcoin\'s Nakamoto consensus, has finality that is probabilistic. The more blocks that get added after that block, the higher the probability that the block will be included in the canonical(network approved) chain. However, this comes with risks - one can never be 100% sure that a block is canonical, although the more blocks built on top of a given block, the less likely it is. Various kinds of double-spend attacks rely on this feature, advertising a block that contains a transaction but does not stay as a part of the canonical chain. \\n\\n#### Let\'s think about this in a real world scenario:\\n\\nLet\'s say we\u2019re buying a cup of coffee. The finality of that transaction is when the cash is handed to the cafe and the employee puts it in the register. Then, the cash value is recorded in the cafe\'s books, stored in an envelope and deposited at their bank; after a few days it becomes available in their account to be used for payroll, rent, and other costs. During each of those steps, the probability that cash value will be reverted, meaning lost or stolen, will become less and less likely.\\n\\t\\n## GRANDPA\\n\\nPolkadot and Kusama have a hybrid consensus model that splits up the responsibilities of consensus into two different modules: GRANDPA, which is the finality module, and BABE is the block production module. BABE (Blind Assignment for Blockchain Extension) produces blocks, and GRANDPA decides which blocks are finalized - that is, what is the provable canonical chain. Note that BABE has its own chain selection rule, but it is probabilistic; however, if there is an issue with getting consensus from the required number of validators for GRANDPA-derived functionality, the network simply reverts to probabilistic finality as opposed to stalling.\\n\\nEach round of GRANDPA votes can finalize many blocks on the canonical chain, significantly increasing the speed of finalization. As long as \u2154 of validators agree on the canonical chain, GRANDPA considers this to be sufficient for finality. If there is a case of less than \u2154 consensus on a new copy of the chain, GRANDPA has mechanisms in place to punish validators that vote on more than one new version of the chain.\\n\\nSplitting up consensus allows us to define network assumptions into the modules, making the consensus model in Polkadot a **deterministic** model. Which we consider to be more secure than a probabilistic model. Especially since block production can continue and not stall even when not enough validators are online, in this case we fall back to the BABE chain selection. GRANDPA is a piece of code that can be plugged into any blockchain; it\'s designed to work on any blockchain implementation as the finality module as long as it is provided with the necessary inputs.\\n\\t\\n## Further reading\\n- GRANDPA paper: https://arxiv.org/pdf/2007.01560.pdf\\n- https://polkadot.network/polkadot-consensus-part-2-grandpa/\\n- https://medium.com/polkadot-network/grandpa-block-finality-in-polkadot-an-introduction-part-1-d08a24a021b5\\n- https://wiki.polkadot.network/docs/learn-consensus#what-is-grandpababe"},{"id":"f-for-forkless","metadata":{"permalink":"/Polkadot-A-to-Z/blog/f-for-forkless","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/F for Forkless/index.md","source":"@site/blog/F for Forkless/index.md","title":"F for Forkless","description":"F for Forkless","date":"2021-12-03T00:21:19.014Z","formattedDate":"December 3, 2021","tags":[],"readingTime":1.86,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"G for Grandpa","permalink":"/Polkadot-A-to-Z/blog/g-for-grandpa"},"nextItem":{"title":"E for Existential Deposit","permalink":"/Polkadot-A-to-Z/blog/e-for-existential-deposit"}},"content":"![F for Forkless](./F.png)\\n\\n## Forking\\n\\nA fork is when a codebase is copied and developed separately from the original version. With open source software, this is legal, though forks can happen in licensed software as well, both legally and illegally. In the realm of blockchain and cryptocurrency projects, forks happen frequently, meaning not only do new copies of the codebase get created and developed as separate projects, but sometimes even certain updates on the same code base require forks. \\nTraditional blockchains like Bitcoin and Ethereum require forks because of their architecture. Bitcoin has been forked thousands of times, and has hundreds of forks that became legitimate blockchain projects, each copy has been developed differently from the original. For example, Bitcoin Cash was a fork of Bitcoin, and so was Bitcoin Gold. But also some not so obvious forks include Ethereum and Litecoin. And sometimes there are levels, for example DogeCoin was a fork of Lucky Coin, which was a Fork of Litecoin, which is a fork of Bitcoin.\\n\\n## Runtime\\n\\nRuntime is the environment in which a piece of software gets executed. This includes the hardware requirements and software changes. An upgrade in runtime is indicated by a change in the version, ie. 1.0.0 to 2.0.0\\n\\n## Hard Fork\\n\\nA hard fork can be two things, a software upgrade to a network, or a split in the network. It is when clients on the network will need to upgrade or switch over to the new version or else it will be incompatible with the new runtime.\\n\\n## Soft fork\\n\\nA soft fork is a backward compatible upgrade. The clients on the network will not need to upgrade to a newer version in order to keep working. \\n\\n## Forkless\\n\\nSubstrate-based chains are able to upload the runtime bytecode as a Wasm(WebAssembly, which we will talk about when we get to letter W) blob. This is done through Polkadots on-chain governance system. If a new runtime is successfully voted on, and the network agrees to the upgrade, the next block will include the runtime upgrade. The participants on the network will then get the newest runtime and henceforth start building blocks with the new version. Forkless upgrades\\n\\n## Further reading\\n- https://wiki.polkadot.network/docs/learn-runtime-upgrades&sa=D&source=editors&ust=1628347324659000&usg=AOvVaw0nEApwum2xo4s3Ggr9rVcp\\n\\n- https://wiki.polkadot.network/docs/learn-wasm"},{"id":"e-for-existential-deposit","metadata":{"permalink":"/Polkadot-A-to-Z/blog/e-for-existential-deposit","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/E for Existential Deposit/index.md","source":"@site/blog/E for Existential Deposit/index.md","title":"E for Existential Deposit","description":"E for Existential Deposit","date":"2021-12-03T00:21:19.012Z","formattedDate":"December 3, 2021","tags":[],"readingTime":1.055,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"F for Forkless","permalink":"/Polkadot-A-to-Z/blog/f-for-forkless"},"nextItem":{"title":"D for Democracy","permalink":"/Polkadot-A-to-Z/blog/d-for-democracy"}},"content":"![E for Existential Deposit](./E.png)\\n\\n## Existential Deposit and reaping\\n\\nAccounts must have a minimum balance to exist on-chain. This minimum balance, called an existential deposit (ED), is used as a financial incentive to keep wallets alive. If a wallet\'s balance falls below the ED, it is considered a dust account, and will be removed from the on-chain data. Once all references to the account have been removed, the account can be reaped (completely emptied). \\n\\nThe ED on Polkadot is **1 DOT** and Kusama is **0.0000333333 KSM**. \\n\\nReaping does not mean the account is no longer usable, however. The keys still exist in the wallet and can be used in the future, and funds can still be transferred to the account, as long as the total funds in the account will exceed the ED. However, if the account was previously reaped, the reaped funds are not recoverable. In order to protect your account from going below the existential deposit amount, the wallet on PolkadotJS has a keep-alive option which will not let transactions take place which would otherwise put the account balance under the ED amount. \\n\\nIf you are a validator, be careful not to deposit any staking rewards to a reaped account, or else those funds will be lost and un-recoverable."},{"id":"d-for-democracy","metadata":{"permalink":"/Polkadot-A-to-Z/blog/d-for-democracy","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/D for Democracy/index.md","source":"@site/blog/D for Democracy/index.md","title":"D for Democracy","description":"D for Democracy","date":"2021-12-03T00:21:19.008Z","formattedDate":"December 3, 2021","tags":[],"readingTime":3.465,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"E for Existential Deposit","permalink":"/Polkadot-A-to-Z/blog/e-for-existential-deposit"},"nextItem":{"title":"C for Collators","permalink":"/Polkadot-A-to-Z/blog/c-for-collators"}},"content":"![D for Democracy](./D.png)\\n\\nDemocracy is a form of governance that society has been practicing in different forms for centuries. At its purest form, it is the decentralization of power. It first appeared in the 5th century BC derived from the Greek word meaning \u201crule of the people\'\' and 26 centuries later taking form in Polkadot, the application of Democracy can be thought of as \u201crule of the stakeholders\u201d. It acts as the **governance** mechanism through which only agreed upon changes to the network by its stakeholders(participants) are able to pass. It is imperative for the network to function as a decentralized system and it also happens to be how the network handles code updates. When a new functionality is proposed, the network participants, that is, the DOT holders, vote on it. And if it passes the Democratic process, it will automatically call the `set_code` function, which will update the runtime code(which is a WebAssembly blob, which we will cover later this year with letter W) of the network. This is how Polkadot works around hard forks which most other blockchains need to use to update their code. \\n\\nSo how does the system work? In simple terms the flow is as follows - **proposal of referenda > voting > enactment**, however, there are many details in the seams of each step that will be abstracted away for the sake of keeping this post simple. Please refer to the [wiki](https://wiki.polkadot.network/docs/maintain-guides-democracy) for a deeper dive into each part.\\n\\n## Proposal of referenda\\n\\nIn Polkadot, the main application of Democracy comes in the form of a public referendum. Referendums are simple, inclusive, stake weighted voting mechanisms and they start with a proposal, which can be enacted in a few different ways: \\n- Publicly submitted proposals\\n- Proposals submitted by the council, either through a majority or unanimously\\n- Proposals submitted as part of the enactment of a prior referendum\\n- Emergency proposals submitted by the Technical Committee and approved by the Council\\n\\n## Voting on referendum proposals\\n\\nProposing requires you to bond some tokens, and once the proposal has been made, the tokens are locked until the proposal has been \u201ctabled\u201d. Meaning, that there was a voting period. Bonded tokens have a lock period, and in Polkadot one lock period is 28 days, and Kusama is 8 days. \\nOnce a proposal has been tabled, voting can begin. In reality, getting voting turnouts to be 100% is extremely rare, so we have developed Adaptive Quorum Biasing. In simple terms, this tool allows the network to intelligently adjust the amount of aye, or nay votes required to successfully pass or not pass a referendum based on the participant turnout.  \\n\\n## Enactment\\n\\nEvery approved proposal will have a period of time before it is enacted, that is, when the set_code function is called. We call this the delayed enactment period, and it allows participants that do not agree with the new update to leave the network, and also those who voted for the proposal will have their bonded DOT locked until the upgrade is executed. \\n\\n## Council\\n\\nAny DOT holder can become elected to the council. This a delegated group of stakeholders that are elected through a rotating approval vote, meaning that the seats in coun  cil are voted on one at a time. Like a few other parts of the network, the elections use the [sequential Phragm\xe9n method](https://wiki.polkadot.network/docs/learn-phragmen). Polkadot currently has 13 council seats and is planning to eventually have 24, while Kusama has 19. Candidates for council bond their DOT in order to be voted for, and their DOT is returned when they\u2019re elected. Top runner-ups are persisted until the next election, meaning their bond stays locked till the next seat is up for election. Council terms are 7 days on Polkadot and 1 day on Kusama. Their role is to control the treasury, propose referenda, cancel dangerous and non-controversial referenda, as well as elect the technical committee. The existence of the council allows the network to have a trusted group that represents the absent participants in order to make sure Democracy is functioning as intended.\\n\\nCheck out [this](https://www.crowdcast.io/e/governance-on-polkadot--/register) crowdcast which dives deeper into the governance of Polkadot."},{"id":"c-for-collators","metadata":{"permalink":"/Polkadot-A-to-Z/blog/c-for-collators","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/C for Collators/index.md","source":"@site/blog/C for Collators/index.md","title":"C for Collators","description":"C for Collators","date":"2021-12-03T00:21:19.002Z","formattedDate":"December 3, 2021","tags":[],"readingTime":1.08,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"D for Democracy","permalink":"/Polkadot-A-to-Z/blog/d-for-democracy"},"nextItem":{"title":"B for Bridges","permalink":"/Polkadot-A-to-Z/blog/b-for-bridges"}},"content":"![C for Collators](./C.png)\\n\\nCollate (verb):\\n- To examine and compare carefully in order to note points of disagreement.\\n- To assemble in proper numerical or logical sequence.\\n\\nCollators are the maintainers of Parachains, which we will cover more in detail when we get to letter P. As a node on the network they have an important task and that is to keep track of both the state of the Polkadot relay chain as well as maintain the state of the given Parachain that they run on. They do this by running a full node of the relay chain and a full node of the parachain and then building parachain blocks along with a proof of validity for those blocks which gets proposed to the Polkadot relay chain validators. Once a block is proposed, they cannot start working on the next block until the relay chain validators accept the validity of the proposed block.\\nUsing Cross-chain message passing(XCMP), which will be covered in letter X, Collators are able to communicate with other Collators of different parachains. This is imperative for allowing multi chain applications to work seamlessly.\\nIf you\u2019re curious about how the technical details of Collators work, check out Cumulous, a set of tools created by Parity to build Polkadot parachains. \\n\\nWorkshop/tutorial: https://substrate.dev/cumulus-workshop/#/  \\nCumulus code: https://github.com/paritytech/cumulus/."},{"id":"b-for-bridges","metadata":{"permalink":"/Polkadot-A-to-Z/blog/b-for-bridges","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/B for Bridges/index.md","source":"@site/blog/B for Bridges/index.md","title":"B for Bridges","description":"B for Bridges","date":"2021-12-03T00:21:19.000Z","formattedDate":"December 3, 2021","tags":[],"readingTime":3.325,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"C for Collators","permalink":"/Polkadot-A-to-Z/blog/c-for-collators"},"nextItem":{"title":"A for Account","permalink":"/Polkadot-A-to-Z/blog/a-for-account"}},"content":"![B for Bridges](./B.png)\\n\\n## What are Bridges?\\n\\n Bridges are connections to the Polkadot relay chain that have special properties which allow them to communicate with other blockchains. They\u2019re secured via the Polkadot consensus and are maintained by a group of participants called Collators which we will cover in next week\'s post for letter C. Bridges are the cornerstone of interoperability that Polkadot is looking to deliver in the blockchain ecosystem. We can think of them as communication channels for different isolated blockchains such as Bitcoin or Ethereum that will be able to send messages, mint new coins, secure locked funds, and burn tokens among other functionality. With a bridge we enable more complex applications to be developed that can use multiple blockchains for functionality and hence combating the issue of chain maximalism.\\n\\n## How do Bridges work?\\n\\nLet\'s think about an example; we have two bridges, one for BTC and another for ETH and Bob wants to transfer BTC to ETH. Polkadot can facilitate this transaction via the use of it\u2019s messaging protocol that allows bridges to communicate with each other, this is called XCMP and we will cover it for the letter X later this year. The BTC bridge will send a message to the ETH bridge with the amount of BTC and Bobs ETH account into which the bridge will deposit the newly minted ETH token, let\'s call this PBTC. The token minting logic is executed by an Ethereum smart contract, which the bridge can trigger. Once the transaction happens on both bridges and the PBTC is minted at a 1:1 ratio as the sent BTC amount, the PBTC is deposited to Bob\'s ETH account. Meanwhile, the original BTC is locked up in the BTC bridge, which will be accessible only by the original sender of the transaction. So if Bob ever wants to transfer the PBTC back into his BTC account, the same smart contract can burn the PBTC on the Ethereum blockchain and take the locked up 1:1 and send it back to Bob\u2019s BTC account. This is all secured by the bridge\'s Collators which are synchronized with the consensus of both the bridged blockchain and the Polkadot blockchain. \\n\\nSee this video for a visual explanation of this process:\\nHow Bitcoin and Ethereum can Cooperate and Collaborate Through Polkadot with Bruno Skvorc\\n\\n\x3c!-- ![How Bitcoin and Ethereum can Cooperate and Collaborate Through Polkadot with Bruno Skvorc](https://www.youtube.com/watch?v=rvoFUiOR3cM) --\x3e\\n\\nhttps://www.youtube.com/watch?v=rvoFUiOR3cM\\n\\n\\n## How can we achieve Bridges?\\n\\nThere are a couple ways to develop a Bridge on Polkadot. Primary way is to use the Bridge pallet through the Substrate framework which the Polkadot and Kusama blockchains are also built with. Another way is to use smart contracts, especially if the blockchain being bridged is not a Substrate chain. For example, bridging Ethereum will require this approach where a smart contract living on Ethereum will be able to execute logic that the bridge requires. And lastly we can use Higher-order protocols like XClaim, a base protocol on which we can build bridges on top of. This is only recommended if the asset being bridged does not have a smart contract platform on-chain, such as BTC.\\n\\n## What are some projects that\u2019re building Bridges, and how can you build a Bridge?\\n\\nBridges are after all software that needs to be written and maintained, so what\u2019re some examples of this in the real world? Interoperability in a decentralized trustless way is a difficult endeavor, and at Web3 we are funding through our grants program different applications looking to build bridges such as ChainSafe and Centrifuge. Another Web3 funded project called PolkaBTC has developed a Substrate bridge to BTC. And ChainX, as mentioned earlier is a protocol that can be utilized to develop bridges and a BTC bridge has been built using that.\\nIf you\u2019re interested in building your own bridge, start by looking into the Parity Bridges Common repository, where the team at Parity have put together a collection of components that are useful when building bridges."},{"id":"a-for-account","metadata":{"permalink":"/Polkadot-A-to-Z/blog/a-for-account","editUrl":"https://github.com/emresurmeli/Polkadot-A-to-Z/blog/A for Account/index.md","source":"@site/blog/A for Account/index.md","title":"A for Account","description":"A for Account","date":"2021-12-03T00:21:18.994Z","formattedDate":"December 3, 2021","tags":[],"readingTime":1.985,"truncated":false,"authors":[{"name":"Emre Surmeli","title":"Technical Educator @ Web3 Foundation","url":"https://github.com/emresurmeli","imageURL":"https://pbs.twimg.com/profile_images/1456026947742572558/SYbenXnu_400x400.jpg","key":"emre"}],"prevItem":{"title":"B for Bridges","permalink":"/Polkadot-A-to-Z/blog/b-for-bridges"}},"content":"![A for Account](./A.png)\\n\\n## What is an account?\\n\\nAccounts are also sometimes referred to as wallets or addresses. On blockchains we need a place to hold our assets, and this is what accounts are used for. A user can have many accounts, and on Polkadot and Kusama, unlike most other public blockchains we can even give accounts on-chain, authenticated, and human readable identities if we would like to. \\n\\n## What a Polkadot account public key looks like\\n\\t14dQ7nC8YabzseZ5iqvG4EQnrkTCsUCwMbCP6nQWeKgjF6Ye\\n\\nAccounts on Polkadot and Kusama are SS58 encoded key-network pairs. By representing an address as a combination of keys and network IDs, it makes sending assets to an address that is unusable much less likely (Ethereum only uses keys; imagine sending ETH from Ethereum mainnet to an account that only exists on Binance Smart Chain, which is another EVM-based chain, and being confused as to why you can\u2019t see the ETH on Binance Smart Chain). SS58 is a slight modification of the Bitcoin Base-58-Check encoding. By using different address prefixes, we can easily tell if an account is on the same chain as another. For example, Polkadot addresses start with a 1, Kusama is always with a capital letter, generic substrate addresses will start with a 5. \\n\\n## Creating an account\\n\\nJust like any other blockchain address, Polkadot and Kusama accounts are controlled with public private key pairs. This is a cryptographic way of creating a public facing id that is intrinsically linked to a private id, which should be kept secret. The address generation starts with a mnemonic phrase which is then converted into a public-private key pair. Because different wallets use different ways to derive the public and private keys from the mnemonic phrase, there can be issues with deriving the same public and private key pairs from the same mnemonic on different wallets.\\n\\n## What a mnemonic phrase looks like:\\n\\tway pumpkin card castle crystal domain mystery chalk dog twin chronic image\\n\\n## Portability\\n\\n Accounts can also be utilized across Substrate chains. Since addresses are the result of encoding a public key and a network ID, we can create an address for another chain by decoding the address, changing the network ID, and encoding the key with the new network ID, resulting in a new address that is controlled by the same underlying key. This allows you to use one mnemonic phrase across multiple Substrate chains."}]}')}}]);